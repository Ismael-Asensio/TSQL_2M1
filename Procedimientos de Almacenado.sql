CREATE DATABASE SistVBX

RESTORE DATABASE SistVBX FROM DISK = 'D:\BDI - 30-08-2023\SistVBX.bak'
WITH REPLACE

USE SistVBX

ALTER TABLE Recintos ADD EstadoR BIT DEFAULT 1

SELECT * FROM Recintos

UPDATE Recintos SET EstadoR=1

-- SE CREA PROCEDIMIENTO

CREATE PROCEDURE NuevoRecinto
@NR NVARCHAR(50),
@U NVARCHAR(50)

AS

DECLARE @nomrec AS NVARCHAR(50)
SET @nomrec = (SELECT NombreRec FROM Recintos WHERE NombreRec = @NR)
IF(@NR = '' OR @U = '')
BEGIN 
	PRINT'No se puede estar en vacio'
END
ELSE
BEGIN
	IF(@NR = @nomrec)
	BEGIN
	PRINT'Recinto ya registrado'
END
	ELSE
	BEGIN
		INSERT INTO Recintos VALUES(@NR,@U,1)
	END
END

-- SE PRUEBA DE QUE EL PROCEDIMIENTO FUNCIONE DE FORMA CORRECTA

NuevoRecinto 'Albert Einstein','Managua'

SELECT * FROM Recintos

-- SE CREA PROCEDIMIENTO PARA DAR DE BAJA

CREATE PROCEDURE DBRec

@IDR INT 
AS 
DECLARE @idrec AS INT 
SET @idrec = (SELECT IdRec FROM Recintos WHERE IdRec = @IDR)
IF(@IDR = @idrec)
	BEGIN
		UPDATE Recintos SET EstadoR = 0 WHERE IdRec = @IDR AND EstadoR = 1
	END
ELSE
	BEGIN
		PRINT'Recinto no encontrado'
	END

-- PROBANDO A DAR DE BAJA A UN RECINTO

DBRec 3

SELECT * FROM Recintos

-- PROCEDIMIENTO A VOLVER A ACTIVAR UN RECINTO

CREATE PROCEDURE DARec

@IDR INT 
AS 
DECLARE @idrec AS INT 
SET @idrec = (SELECT IdRec FROM Recintos WHERE IdRec = @IDR)

IF(@IDR = @idrec)
	BEGIN
		UPDATE Recintos SET EstadoR = 1 WHERE IdRec = @IDR AND EstadoR = 0
	END
ELSE
	BEGIN
		PRINT'Recinto no encontrado'
	END

DARec 3

SELECT * FROM Recintos

-- PROECEDIMIENTO MODIFICAR RECINTO

CREATE PROCEDURE ModRec

@IDR INT,
@NR NVARCHAR(50),
@U  NVARCHAR(50)

AS
DECLARE @idrec AS INT
SET @idrec = (SELECT IdRec FROM Recintos WHERE IdRec = @IDR)

DECLARE @nomrec AS NVARCHAR
SET @nomrec = (SELECT NombreRec FROM Recintos WHERE NombreRec = @NR)

IF(@IDR = @idrec)
	BEGIN
		IF(@NR = '' OR @U = '')
			BEGIN
				PRINT 'No puede ser nulo'
			END
		ELSE
			BEGIN
				IF(@NR = @nomrec)
					BEGIN
						PRINT 'No puede duplicarse los nombres'
					END
			ELSE
				BEGIN
					UPDATE Recintos SET NombreRec = @NR , Ubicacion = @U WHERE IdRec = @IDR AND EstadoR = 1
				END
		END
	END
ELSE
	BEGIN
		PRINT 'Rencinto no encontrado'
	END

-- PROBANDO PROCEDIMIENTO DE ACTUALIZAR

ModRec 2,'Aldo Urbina','Juigalpa'

SELECT * FROM Recintos


-- CREANDO PROCEDIMIENTO DE BUSQUEDA

CREATE PROCEDURE BRect
@IDR INT 
AS
DECLARE @idrec AS INT
SET @idrec = (SELECT IdRec FROM Recintos WHERE IdRec = @IDR)
IF(@IDR = @idrec)
	BEGIN
		SELECT * FROM Recintos WHERE IdRec = @IDR
	END
ELSE
	BEGIN
		PRINT 'Recinto no encontrado' 
	END

BRect 2

-- LISTAR RECINTOS ACTIVOS

CREATE PROCEDURE LisRA
AS
SELECT * FROM Recintos WHERE EstadoR = 1

-- LISTAR RECINTOS INACTIVOS

CREATE PROCEDURE LisRI
AS
SELECT * FROM Recintos WHERE EstadoR = 0

LisRA
LisRI

SELECT * FROM Facultad

ALTER TABLE Facultad ADD EstadoR BIT DEFAULT 1

UPDATE Facultad SET EstadoR = 1

-- PROCEDIMIENTO DE AGREGADO

CREATE PROCEDURE NuevaF
@CF CHAR(5),
@NF NVARCHAR(50), 
@TE INT,
@NA NVARCHAR(50),
@IDR INT

AS

DECLARE @nomf AS NVARCHAR(50)
DECLARE @idrec AS INT

SET @idrec = (SELECT IdRec FROM Recintos WHERE IdRec = @IDR)
SET @nomf = (SELECT NombreFac FROM Facultad WHERE NombreFac = @NF)

IF(@CF = NULL OR @NF = '' OR @TE = NULL OR @NA = '' OR @IDR = NULL)
	BEGIN
		PRINT 'No pueden haber campos vacios'
	END
ELSE
	BEGIN
		IF(@idrec <> @IDR)
			BEGIN
				PRINT 'Ese recinto no existe'
			END
		ELSE IF(@NF = @nomf)
			BEGIN
				PRINT 'Esta facultad ya esta registrada'
			END
		ELSE
			BEGIN
				INSERT INTO Facultad VALUES(@CF,@NF,@TE,@NA,@IDR,1)
			END
	END
	
NuevaF 04,'FTI',60,'JoseLui',5

SELECT * FROM Facultad

SELECT * FROM Productos

-- CLASE 07-09-2023

CREATE VIEW FnA 

AS
SELECT MIN(preciop) AS PrecioMin,
MAX(preciop) AS PrecioMax, AVG(preciop) AS PrecioProm,
COUNT(CodProd) AS CantPro, SUM(existp) AS CantExist,
VAR(preciop) AS VarianzaP, STDEV(preciop)AS DesviEsP

FROM Productos

SELECT * FROM FnA


/*
	FUNCIONES STANDAR DEL SISTEMA
	I- FUNCIONES DE FECHA Y HORA
		1. GETDATE() : RETORNA LA FECHA Y HORA DEL SISTEMA
		2. YEAR() : OBTENER UN AÑO A PARTIR DE UNA FECHA
		3. MOTH() : OBTENER EL MES A PARTIR DE UNA FECHA
		4. DAY() : OBTENET EL DIA A PARTIR DE UNA FECHA
		5. DATENAME()
		6. DATEDIFF() : DIFERENCIA DE FECHAS
		7. DATEADD() : SUMA DE FECHAS
		8. DATEPART() : OBTENER LA PARTE DE UNA FECHA

	II- FUNCIONES DE TIPO CADENA
		1. LEN() : DEVUELVE LA LONGITUD DE UNA CADENA
		2. CHAR() : DEVUELVE EL CARACTER SEGÚN EL CODIGO ASCII
		3. ASCII() : DEVUELVE EL CODIGO DEL CARACTER
		4. LOWER() : TRANSFORMA A MINÚSCULA
		5. UPPER() : TRANSFORMA A MAYÚSCULA
		6. REVERSE() : INVIERTE UNA CADENA
		7. LTRIM() : ELIMINAR LOS ESPACIOS EN BLANCO A LA IZQUIERDA
		8. RTRIM() : ELIMINAR LOS ESPACIOS EN BLANCO A LA DERECHA
		9. TRIM() ELIMINAR ESPACIOS EN BLANCO EN DERECHA E IZQUIERDA
		10. SUBSTRING() : ABSTRAER UNA SUBCADENA
		11. CONCAT() : UNE VALORES

	III- FUNCIONES DE CONVERSION
		CAST,CONVERT,PARSE,TRY_CAST,TRY_CONVERT,TRY_PARSE : CONVIERTE DE UN DATO A OTRO
*/

SELECT GETDATE() AS FHAct
SELECT YEAR(GETDATE()) AS _YEAR, YEAR('1990-10-02') AS BORN_YEAR
SELECT MONTH(GETDATE()) AS _MONTH, MONTH('1990-10-02') AS BORN_MONTH
SELECT DAY(GETDATE()) AS _DAY, DAY('1990-10-02') AS BORN_DAY

SELECT DATENAME(WEEKDAY, GETDATE()) AS A_DAY,
DATENAME(WEEKDAY,'2006-01-05') AS BORN_DAY,
DATENAME(DAYOFYEAR,GETDATE()) AS NUM_DAY_A,
DATENAME(DAYOFYEAR,'2006-01-05') AS NUM_BORN_DAY

SELECT DATEDIFF(YEAR,'2006-01-05', GETDATE()) AS _YEARS,
DATEDIFF(MONTH,'2006-01-05', GETDATE()) AS _YEARSN_MONTHS,
DATEDIFF(WEEK,'2006-01-05', GETDATE()) AS _YEARSN_WEEKS,
DATEDIFF(DAY,'2006-01-05', GETDATE()) AS _YEARSN_DAYS,
DATEDIFF(HOUR,'2006-01-05', GETDATE()) AS _YEARSN_HOURS

SELECT DATEADD(DAY,7,GETDATE()) AS SEVEN_DAYSA

SELECT DATEPART(YEAR,GETDATE()) AS _YERA,
DATEPART(MONTH,GETDATE()) AS _MONTHA,
DATEPART(WEEK,GETDATE()) AS _WEEKA,
DATEPART(DAY,GETDATE()) AS _DAYA

SELECT LEN('LUISA') AS _LETTERS
SELECT CHAR(94) AS _CHAR
SELECT ASCII('Ñ') AS _ASCII
SELECT LOWER('LUISA') _LOWER
SELECT UPPER('luisa') _UPPER
SELECT REVERSE('OMA ET') _REVERSE
SELECT LTRIM(' :3 ') _LTRIM
SELECT RTRIM(' :3 ') _RTRIM
SELECT TRIM(' :3 ') _TRIM
SELECT SUBSTRING('001-070205-1006M',5,6) AS BORN_DAY
SELECT CONCAT('HAPPY','ANIVERSAY',1,'/',8)